/*
 * Copyright (c) 2018 Aspose Pty Ltd. All Rights Reserved.
 *
 * Licensed under the MIT (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://github.com/aspose-omr-cloud/aspose-omr-cloud-nodejs/blob/master/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Aspose.OMR for Cloud API Reference
 * Aspose.OMR for Cloud helps performing optical mark recognition in the cloud
 *
 * OpenAPI spec version: 1.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require('request');
import http = require('http');
import {URL} from "url";
import querystring = require('querystring');

let defaultBasePath = 'https://localhost/v1.1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}
/**************** Model ********************/
/**
* The basic AsposeResponse response class kept from the old Aspose for Cloud Platform. We keep this base class and use it because most probably users are already using it to get API responses. The plan in future is to get rid of this name, but who knows when ?!
*/
export class AsposeResponse {
    /**
    * Indicates operation's status
    */
    'status': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "Status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AsposeResponse.attributeTypeMap;
    }
}

/**
* Represents information about file.
*/
export class FileInfo {
    /**
    * Name of the file
    */
    'name': string;
    /**
    * Size of the image in bytes
    */
    'size': number;
    /**
    * File data packed in base64 string
    */
    'data': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "Size",
            "type": "number"
        },
        {
            "name": "data",
            "baseName": "Data",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FileInfo.attributeTypeMap;
    }
}

/**
* Represents information about file.
*/
export class OMRFunctionParam {
    /**
    * FunctionParam  depends on operation
    */
    'functionParam': string;
    /**
    * AdditionalParam depends on operation 
    */
    'additionalParam': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "functionParam",
            "baseName": "FunctionParam",
            "type": "string"
        },
        {
            "name": "additionalParam",
            "baseName": "AdditionalParam",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OMRFunctionParam.attributeTypeMap;
    }
}

/**
* Structure that holds additional information regarding performed task.
*/
export class OMRResponseDetails {
    /**
    * Warnings and other messages regarding task, etc.
    */
    'taskMessages': Array<string>;
    /**
    * Indicates if each particular task passed or failed,
    */
    'taskResult': string;
    /**
    * RecognitionStatistics
    */
    'recognitionStatistics': Array<RecognitionStatistics>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "taskMessages",
            "baseName": "TaskMessages",
            "type": "Array<string>"
        },
        {
            "name": "taskResult",
            "baseName": "TaskResult",
            "type": "string"
        },
        {
            "name": "recognitionStatistics",
            "baseName": "RecognitionStatistics",
            "type": "Array<RecognitionStatistics>"
        }    ];

    static getAttributeTypeMap() {
        return OMRResponseDetails.attributeTypeMap;
    }
}

/**
* Represents information about part of the text.
*/
export class OmrResponseContent {
    /**
    * GUID string that is used to identify template on server This value is assigned after Template Correction and used later in Template Finalization and Image Recognition
    */
    'templateId': string;
    /**
    * Indicates how long it took to perform task on server.
    */
    'executionTime': number;
    /**
    * This structure holds array of files returned in response Type and content of files differes depending on action
    */
    'responseFiles': Array<FileInfo>;
    'info': OmrResponseInfo;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "templateId",
            "baseName": "TemplateId",
            "type": "string"
        },
        {
            "name": "executionTime",
            "baseName": "ExecutionTime",
            "type": "number"
        },
        {
            "name": "responseFiles",
            "baseName": "ResponseFiles",
            "type": "Array<FileInfo>"
        },
        {
            "name": "info",
            "baseName": "Info",
            "type": "OmrResponseInfo"
        }    ];

    static getAttributeTypeMap() {
        return OmrResponseContent.attributeTypeMap;
    }
}

/**
* Represents information about OMR result.
*/
export class OmrResponseInfo {
    /**
    * String value representing version of the response.
    */
    'responseVersion': string;
    /**
    * Total amount of processed tasks
    */
    'processedTasksCount': number;
    /**
    * Total amount of successful tasks, i.e. tasks that completed without errors
    */
    'successfulTasksCount': number;
    /**
    * Additional information regarding performed task.
    */
    'details': OMRResponseDetails;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "responseVersion",
            "baseName": "ResponseVersion",
            "type": "string"
        },
        {
            "name": "processedTasksCount",
            "baseName": "ProcessedTasksCount",
            "type": "number"
        },
        {
            "name": "successfulTasksCount",
            "baseName": "SuccessfulTasksCount",
            "type": "number"
        },
        {
            "name": "details",
            "baseName": "Details",
            "type": "OMRResponseDetails"
        }    ];

    static getAttributeTypeMap() {
        return OmrResponseInfo.attributeTypeMap;
    }
}

/**
* Represents information about file.
*/
export class Payload {
    /**
    * OMR result
    */
    'result': OmrResponseContent;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "result",
            "baseName": "Result",
            "type": "OmrResponseContent"
        }    ];

    static getAttributeTypeMap() {
        return Payload.attributeTypeMap;
    }
}

/**
* OMRResponseDetails
*/
export class RecognitionStatistics {
    /**
    * Gets or sets Name
    */
    'name': string;
    /**
    * Warnings and other messages regarding task, etc.
    */
    'taskMessages': Array<string>;
    /**
    * Indicates if each particular task passed or failed,
    */
    'taskResult': string;
    /**
    * Gets or sets RunSeconds
    */
    'runSeconds': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "Name",
            "type": "string"
        },
        {
            "name": "taskMessages",
            "baseName": "TaskMessages",
            "type": "Array<string>"
        },
        {
            "name": "taskResult",
            "baseName": "TaskResult",
            "type": "string"
        },
        {
            "name": "runSeconds",
            "baseName": "RunSeconds",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RecognitionStatistics.attributeTypeMap;
    }
}

/**
* Represents information about part of the text.
*/
export class ServerStat {
    /**
    * Get or set StorageDownloadTime
    */
    'storageDownloadTime': string;
    /**
    * Get or set OmrFunctionCallTime
    */
    'omrFunctionCallTime': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "storageDownloadTime",
            "baseName": "StorageDownloadTime",
            "type": "string"
        },
        {
            "name": "omrFunctionCallTime",
            "baseName": "OmrFunctionCallTime",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ServerStat.attributeTypeMap;
    }
}

/**
* Represents information about response after OMR.
*/
export class OMRResponse {
    /**
    * Indicates operation's status
    */
    'status': string;
    /**
    * Integer field that indicates whether any critical errors occured during task execution
    */
    'errorCode': number;
    /**
    * String description of occured critical error. Empty if no critical errors occured
    */
    'errorText': string;
    /**
    * Payload
    */
    'payload': Payload;
    /**
    * Server statistics
    */
    'serverStat': ServerStat;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "Status",
            "type": "string"
        },
        {
            "name": "errorCode",
            "baseName": "ErrorCode",
            "type": "number"
        },
        {
            "name": "errorText",
            "baseName": "ErrorText",
            "type": "string"
        },
        {
            "name": "payload",
            "baseName": "Payload",
            "type": "Payload"
        },
        {
            "name": "serverStat",
            "baseName": "ServerStat",
            "type": "ServerStat"
        }    ];

    static getAttributeTypeMap() {
        return OMRResponse.attributeTypeMap;
    }
}

/**************** Model ********************/

let enumsMap = {
}

let typeMap = {
    "AsposeResponse": AsposeResponse,
    "FileInfo": FileInfo,
    "OMRFunctionParam": OMRFunctionParam,
    "OMRResponseDetails": OMRResponseDetails,
    "OmrResponseContent": OmrResponseContent,
    "OmrResponseInfo": OmrResponseInfo,
    "Payload": Payload,
    "RecognitionStatistics": RecognitionStatistics,
    "ServerStat": ServerStat,
    "OMRResponse": OMRResponse,
}
enum OAuth2Flow {
    ObtainAccessTokenPending,
    RefreshAccessTokenPending,
    Obtained
}

class OAuth2 {
    private flow : OAuth2Flow;
    private basePath: string = "";
    private appsid: string = "";
    private appkey: string = "";

    private access_token: string = "";
    private refresh_token: string = "";
    constructor(appsid: string, appkey: string, basePath: string) {
        this.appsid = appsid;
        this.appkey = appkey;
        this.basePath = basePath;

        this.flow = OAuth2Flow.ObtainAccessTokenPending;
    }
    get tokenUrl() {
        let url : URL= new URL(this.basePath);

        return new URL('/oauth2/token', url.origin).toString();
    }

    public refreshToken() {
        this.flow = OAuth2Flow.RefreshAccessTokenPending;
    }

    public authenticate() {
        if (OAuth2Flow.Obtained == this.flow) {
            return Promise.resolve({token : this.access_token});
        }

        let requestOptions: request.Options = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            uri: this.tokenUrl,
            json: false,
        };
        let params = {};

        if (OAuth2Flow.ObtainAccessTokenPending == this.flow) {
            params = {
                'grant_type': 'client_credentials'
                , 'client_id': this.appsid
                , 'client_secret': this.appkey
            };
        } else if (OAuth2Flow.RefreshAccessTokenPending == this.flow) {
            params = {
                'grant_type': 'refresh_token'
                , 'refresh_token': this.refresh_token
            };
        }
        requestOptions.body = querystring.stringify(params);

        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        }).then(({response, body}) => {
            //console.info('auth response body ' + body);
            var obj = JSON.parse(body);
            this.flow = OAuth2Flow.Obtained;
            this.access_token = obj.access_token;
            this.refresh_token = obj.refresh_token;
            //console.info('auth access_token ' + obj.access_token);

            return Promise.resolve({token : this.access_token});
        });
    }
}


export class OmrApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    private _oauth2 : OAuth2 = null;
    
    constructor(appSid: string, appKey: string, basePath: string) {
        this._oauth2 = new OAuth2(appSid, appKey, basePath);
        this.basePath = basePath;
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }
    private updateToken(token: string, requestOptions: request.Options) {
        if (token != "")
            requestOptions.headers["Authorization"] = "Bearer " + token;
    }
    private invoke_postRunOmrTask(requestOptions: request.Options, n : number) : Promise<{ response: http.IncomingMessage; body: OMRResponse;  }> {
        return this._oauth2.authenticate().then(({token}) => {
            this.updateToken(token, requestOptions);
            return new Promise<{ response: http.IncomingMessage; body: OMRResponse;  }>((resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, "OMRResponse");
                        if (response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else if (n > 0 && (response.statusCode == 401 || response.statusCode == 403)) {
                            this._oauth2.refreshToken();
                            return this.invoke_postRunOmrTask(requestOptions, n - 1);
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            });
        });        
    }
    
    /**
     * 
     * @summary Run specific OMR task
     * @param name Name of the file to recognize.
     * @param actionName Action name [&#39;CorrectTemplate&#39;, &#39;FinalizeTemplate&#39;, &#39;RecognizeImage&#39;]
     * @param param Function params, specific for each actionName
     * @param storage Image&#39;s storage.
     * @param folder Image&#39;s folder.
     */
    public postRunOmrTask (name: string, actionName: string, param?: OMRFunctionParam, storage?: string, folder?: string) : Promise<{ response: http.IncomingMessage; body: OMRResponse;  }> {
        const localVarPath = this.basePath + '/omr/{name}/runOmrTask'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postRunOmrTask.');
        }

        // verify required parameter 'actionName' is not null or undefined
        if (actionName === null || actionName === undefined) {
            throw new Error('Required parameter actionName was null or undefined when calling postRunOmrTask.');
        }

        if (actionName !== undefined) {
            queryParameters['actionName'] = ObjectSerializer.serialize(actionName, "string");
        }

        if (storage !== undefined) {
            queryParameters['storage'] = ObjectSerializer.serialize(storage, "string");
        }

        if (folder !== undefined) {
            queryParameters['folder'] = ObjectSerializer.serialize(folder, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(param, "OMRFunctionParam")
        };

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return this.invoke_postRunOmrTask(requestOptions, 2);
    }
}
